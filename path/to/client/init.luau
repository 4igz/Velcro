--!native
--!optimize 2
--!nocheck
--!nolint
--#selene: allow(unused_variable, shadowing, incorrect_standard_library_use)
-- Client generated by Zap v0.6.2 (https://github.com/red-blox/zap)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local outgoing_buff: buffer
local outgoing_used: number
local outgoing_size: number
local outgoing_inst: { Instance }
local outgoing_apos: number

local incoming_buff: buffer
local incoming_read: number
local incoming_inst: { Instance }
local incoming_ipos: number

-- thanks to https://dom.rojo.space/binary.html#cframe
local CFrameSpecialCases = {
	CFrame.Angles(0, 0, 0),
	CFrame.Angles(math.rad(90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(180)),
	CFrame.Angles(math.rad(-90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(90)),
	CFrame.Angles(0, math.rad(90), math.rad(90)),
	CFrame.Angles(0, 0, math.rad(90)),
	CFrame.Angles(0, math.rad(-90), math.rad(90)),
	CFrame.Angles(math.rad(-90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(-90), 0),
	CFrame.Angles(math.rad(90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(90), math.rad(180)),
	CFrame.Angles(0, math.rad(-90), math.rad(180)),
	CFrame.Angles(0, math.rad(180), math.rad(0)),
	CFrame.Angles(math.rad(-90), math.rad(-180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(180)),
	CFrame.Angles(math.rad(90), math.rad(180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(-90)),
	CFrame.Angles(0, math.rad(-90), math.rad(-90)),
	CFrame.Angles(0, math.rad(-180), math.rad(-90)),
	CFrame.Angles(0, math.rad(90), math.rad(-90)),
	CFrame.Angles(math.rad(90), math.rad(90), 0),
	CFrame.Angles(0, math.rad(90), 0),
	CFrame.Angles(math.rad(-90), math.rad(90), 0),
}

local function alloc(len: number)
	if outgoing_used + len > outgoing_size then
		while outgoing_used + len > outgoing_size do
			outgoing_size = outgoing_size * 2
		end

		local new_buff = buffer.create(outgoing_size)
		buffer.copy(new_buff, 0, outgoing_buff, 0, outgoing_used)

		outgoing_buff = new_buff
	end

	outgoing_apos = outgoing_used
	outgoing_used = outgoing_used + len

	return outgoing_apos
end

local function read(len: number)
	local pos = incoming_read
	incoming_read = incoming_read + len

	return pos
end

local function save()
	return {
		buff = outgoing_buff,
		used = outgoing_used,
		size = outgoing_size,
		inst = outgoing_inst,
	}
end

local function load(data: {
	buff: buffer,
	used: number,
	size: number,
	inst: { Instance },
})
	outgoing_buff = data.buff
	outgoing_used = data.used
	outgoing_size = data.size
	outgoing_inst = data.inst
end

local function load_empty()
	outgoing_buff = buffer.create(64)
	outgoing_used = 0
	outgoing_size = 64
	outgoing_inst = {}
end

load_empty()

local types = {}
if RunService:IsServer() then
	error("Cannot use the client module on the server!")
end

local reliable = ReplicatedStorage:WaitForChild("ZAP_RELIABLE")
local unreliable = ReplicatedStorage:WaitForChild("ZAP_UNRELIABLE")

assert(reliable:IsA("RemoteEvent"), "Expected ZAP_RELIABLE to be a RemoteEvent")
assert(unreliable:IsA("UnreliableRemoteEvent"), "Expected ZAP_UNRELIABLE to be an UnreliableRemoteEvent")

local time = 0
export type Skill = ({
	unlocked: (boolean),
	level: (number),
})
function types.write_Skill(value: Skill)
	alloc(1)
	buffer.writeu8(outgoing_buff, outgoing_apos, value.unlocked and 1 or 0)
	alloc(4)
	buffer.writei32(outgoing_buff, outgoing_apos, value.level)
end
function types.read_Skill()
	local value;
	value = {}
	value.unlocked = buffer.readu8(incoming_buff, read(1)) == 1
	value.level = buffer.readi32(incoming_buff, read(4))
	return value
end
export type WeaponSkills = ({ [(string)]: (Skill) })
function types.write_WeaponSkills(value: WeaponSkills)
	local len_pos = alloc(2)
	local len = 0
	for k, v in value do
		len = len + 1
		local len = #k
		alloc(2)
		buffer.writeu16(outgoing_buff, outgoing_apos, len)
		alloc(len)
		buffer.writestring(outgoing_buff, outgoing_apos, k, len)
		types.write_Skill(v)
	end
	buffer.writeu16(outgoing_buff, len_pos, len)
end
function types.read_WeaponSkills()
	local value;
	value = {}
	for _ = 1, buffer.readu16(incoming_buff, read(2)) do
		local key
		local val
		local len = buffer.readu16(incoming_buff, read(2))
		key = buffer.readstring(incoming_buff, read(len), len)
		val = types.read_Skill()
		value[key] = val
	end
	return value
end
export type SkillTree = ({
	pistol: (WeaponSkills),
	sniper: (WeaponSkills),
	shotgun: (WeaponSkills),
	rifle: (WeaponSkills),
	smg: (WeaponSkills),
})
function types.write_SkillTree(value: SkillTree)
	types.write_WeaponSkills(value.pistol)
	types.write_WeaponSkills(value.sniper)
	types.write_WeaponSkills(value.shotgun)
	types.write_WeaponSkills(value.rifle)
	types.write_WeaponSkills(value.smg)
end
function types.read_SkillTree()
	local value;
	value = {}
	value.pistol = types.read_WeaponSkills()
	value.sniper = types.read_WeaponSkills()
	value.shotgun = types.read_WeaponSkills()
	value.rifle = types.read_WeaponSkills()
	value.smg = types.read_WeaponSkills()
	return value
end

RunService.Heartbeat:Connect(function(dt)
	time += dt

	if time >= (1 / 61) then
		time -= (1 / 61)

		if outgoing_used ~= 0 then
			local buff = buffer.create(outgoing_used)
			buffer.copy(buff, 0, outgoing_buff, 0, outgoing_used)

			reliable:FireServer(buff, outgoing_inst)

			outgoing_buff = buffer.create(64)
			outgoing_used = 0
			outgoing_size = 64
			table.clear(outgoing_inst)
		end
	end
end)

local events = table.create(22)
local event_queue: { [number]: { any } } = table.create(22)
local function_call_id = 0
event_queue[1] = {}
event_queue[7] = {}
event_queue[8] = {}
event_queue[9] = {}
event_queue[10] = {}
event_queue[11] = {}
event_queue[12] = {}
event_queue[16] = {}
event_queue[17] = table.create(255)
event_queue[18] = table.create(255)
event_queue[19] = table.create(255)
event_queue[20] = table.create(255)
event_queue[21] = table.create(255)
event_queue[22] = table.create(255)
reliable.OnClientEvent:Connect(function(buff, inst)
	incoming_buff = buff
	incoming_inst = inst
	incoming_read = 0
	incoming_ipos = 0
	local len = buffer.len(buff)
	while incoming_read < len do
		local id = buffer.readu8(buff, read(1))
		if id == 1 then
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			if events[1] then
				task.spawn(events[1], value)
			else
				table.insert(event_queue[1], value)
				if #event_queue[1] > 64 then
					warn(`[ZAP] {#event_queue[1]} events in queue for updatedSkillUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 8 then
			local value
			value = {}
			incoming_ipos = incoming_ipos + 1
			value.firepoint = incoming_inst[incoming_ipos]
			assert(value.firepoint ~= nil)
			assert(value.firepoint:IsA("Attachment"))
			value.hit = Vector3.new(buffer.readf32(incoming_buff, read(4)), buffer.readf32(incoming_buff, read(4)), buffer.readf32(incoming_buff, read(4)))
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value.beamColor = incoming_inst[incoming_ipos]
			else
				value.beamColor = nil
			end
			if events[8] then
				task.spawn(events[8], value)
			else
				table.insert(event_queue[8], value)
				if #event_queue[8] > 64 then
					warn(`[ZAP] {#event_queue[8]} events in queue for replicateCast. Did you forget to attach a listener?`)
				end
			end
		elseif id == 9 then
			local value
			value = {}
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.zombies = buffer.readu16(incoming_buff, read(2))
			else
				value.zombies = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wave = buffer.readu16(incoming_buff, read(2))
			else
				value.wave = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wavesTillBoss = buffer.readu16(incoming_buff, read(2))
			else
				value.wavesTillBoss = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.timeLeft = buffer.readf64(incoming_buff, read(8))
			else
				value.timeLeft = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.gameActive = buffer.readu8(incoming_buff, read(1)) == 1
			else
				value.gameActive = nil
			end
			if events[9] then
				task.spawn(events[9], value)
			else
				table.insert(event_queue[9], value)
				if #event_queue[9] > 64 then
					warn(`[ZAP] {#event_queue[9]} events in queue for updateUI. Did you forget to attach a listener?`)
				end
			end
		elseif id == 10 then
			local value
			value = {}
			value.level = buffer.readu32(incoming_buff, read(4))
			value.xp = buffer.readu32(incoming_buff, read(4))
			value.xpMax = buffer.readu32(incoming_buff, read(4))
			if events[10] then
				task.spawn(events[10], value)
			else
				table.insert(event_queue[10], value)
				if #event_queue[10] > 64 then
					warn(`[ZAP] {#event_queue[10]} events in queue for updateLevelUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 11 then
			local value
			value = {}
			local len = buffer.readu16(incoming_buff, read(2))
			value.type = buffer.readstring(incoming_buff, read(len), len)
			value.amtGain = buffer.readi32(incoming_buff, read(4))
			local len = buffer.readu16(incoming_buff, read(2))
			value.reason = buffer.readstring(incoming_buff, read(len), len)
			if events[11] then
				task.spawn(events[11], value)
			else
				table.insert(event_queue[11], value)
				if #event_queue[11] > 64 then
					warn(`[ZAP] {#event_queue[11]} events in queue for updateFeeds. Did you forget to attach a listener?`)
				end
			end
		elseif id == 12 then
			local value
			value = {}
			local len = buffer.readu16(incoming_buff, read(2))
			for i = 1, len do
				local value_v
				local len = buffer.readu16(incoming_buff, read(2))
				value_v = buffer.readstring(incoming_buff, read(len), len)
				value[i] = value_v
			end
			if events[12] then
				task.spawn(events[12], value)
			else
				table.insert(event_queue[12], value)
				if #event_queue[12] > 64 then
					warn(`[ZAP] {#event_queue[12]} events in queue for showVoteUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 16 then
			local value
			local len = buffer.readu16(incoming_buff, read(2))
			value = buffer.readstring(incoming_buff, read(len), len)
			if events[16] then
				task.spawn(events[16], value)
			else
				table.insert(event_queue[16], value)
				if #event_queue[16] > 64 then
					warn(`[ZAP] {#event_queue[16]} events in queue for tpToMap. Did you forget to attach a listener?`)
				end
			end
		elseif id == 17 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			task.spawn(event_queue[17][call_id], value)
			event_queue[17][call_id] = nil
		elseif id == 18 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = buffer.readf64(incoming_buff, read(8))
			task.spawn(event_queue[18][call_id], value)
			event_queue[18][call_id] = nil
		elseif id == 19 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.skillPoints = buffer.readi32(incoming_buff, read(4))
			value.rampageEssence = buffer.readi32(incoming_buff, read(4))
			task.spawn(event_queue[19][call_id], value)
			event_queue[19][call_id] = nil
		elseif id == 20 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.zombies = buffer.readi32(incoming_buff, read(4))
			else
				value.zombies = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wave = buffer.readu16(incoming_buff, read(2))
			else
				value.wave = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wavesTillBoss = buffer.readu16(incoming_buff, read(2))
			else
				value.wavesTillBoss = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.timeLeft = buffer.readf64(incoming_buff, read(8))
			else
				value.timeLeft = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.gameActive = buffer.readu8(incoming_buff, read(1)) == 1
			else
				value.gameActive = nil
			end
			task.spawn(event_queue[20][call_id], value)
			event_queue[20][call_id] = nil
		elseif id == 21 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.level = buffer.readu32(incoming_buff, read(4))
			value.xp = buffer.readu32(incoming_buff, read(4))
			value.xpMax = buffer.readu32(incoming_buff, read(4))
			task.spawn(event_queue[21][call_id], value)
			event_queue[21][call_id] = nil
		elseif id == 22 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.equippedWeapons = {}
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.gun = buffer.readstring(incoming_buff, read(len), len)
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.melee = buffer.readstring(incoming_buff, read(len), len)
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.equipment = buffer.readstring(incoming_buff, read(len), len)
			value.ownedWeapons = {}
			local len = buffer.readu16(incoming_buff, read(2))
			for i = 1, len do
				local value_ownedWeapons_v
				local len = buffer.readu16(incoming_buff, read(2))
				value_ownedWeapons_v = buffer.readstring(incoming_buff, read(len), len)
				value.ownedWeapons[i] = value_ownedWeapons_v
			end
			task.spawn(event_queue[22][call_id], value)
			event_queue[22][call_id] = nil
		else
			error("Unknown event id")
		end
	end
end)
unreliable.OnClientEvent:Connect(function(buff, inst)
	incoming_buff = buff
	incoming_inst = inst
	incoming_read = 0
	incoming_ipos = 0
	local id = buffer.readu8(buff, read(1))
	if id == 7 then
		local value
		value = {}
		local len = buffer.readu16(incoming_buff, read(2))
		assert(len <= 50)
		value.weaponName = buffer.readstring(incoming_buff, read(len), len)
		if buffer.readu8(incoming_buff, read(1)) == 1 then
			local len = buffer.readu16(incoming_buff, read(2))
			assert(len <= 20)
			value.victim = buffer.readstring(incoming_buff, read(len), len)
		else
			value.victim = nil
		end
		if events[7] then
			task.spawn(events[7], value)
		else
			table.insert(event_queue[7], value)
			if #event_queue[7] > 64 then
				warn(`[ZAP] {#event_queue[7]} events in queue for replicateHit. Did you forget to attach a listener?`)
			end
		end
	else
		error("Unknown event id")
	end
end)
return {
	upgradeSkill = {
		Fire = function(Value: ({
			weapon: (string),
			skill: (number),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 2)
			local len = #Value.weapon
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weapon, len)
			alloc(4)
			buffer.writei32(outgoing_buff, outgoing_apos, Value.skill)
		end,
	},
	buyWeapon = {
		Fire = function(Value: ({
			weaponName: (string),
			weaponType: (string),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 3)
			local len = #Value.weaponName
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weaponName, len)
			local len = #Value.weaponType
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weaponType, len)
		end,
	},
	equipWeapon = {
		Fire = function(Value: (string))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 4)
			local len = #Value
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value, len)
		end,
	},
	fireGun = {
		Fire = function(Value: ({
			hitPos: (Vector3),
			rayHit: ((Instance)?),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 5)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.X)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Y)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Z)
			if Value.rayHit == nil then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 0)
			else
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 1)
				table.insert(outgoing_inst, Value.rayHit)
			end
		end,
	},
	melee = {
		Fire = function()
			local saved = save()
			load_empty()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 6)
			local buff = buffer.create(outgoing_used)
			buffer.copy(buff, 0, outgoing_buff, 0, outgoing_used)
			unreliable:FireServer(buff, outgoing_inst)
			load(saved)
		end,
	},
	voteForMap = {
		Fire = function(Value: (string))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 13)
			local len = #Value
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value, len)
		end,
	},
	deployed = {
		Fire = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 14)
		end,
	},
	attributeChangedEvent = {
		Fire = function(Value: ({
			name: (string),
			value: ({
				type: "num",
				value: (number),
			} | {
				type: "str",
				value: (string),
			} | {
				type: "boo",
				value: (boolean),
			}),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 15)
			local len = #Value.name
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.name, len)
			if Value.value.type == "num" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 0)
				alloc(8)
				buffer.writef64(outgoing_buff, outgoing_apos, Value.value.value)
			elseif Value.value.type == "str" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 1)
				local len = #Value.value.value
				alloc(2)
				buffer.writeu16(outgoing_buff, outgoing_apos, len)
				alloc(len)
				buffer.writestring(outgoing_buff, outgoing_apos, Value.value.value, len)
			elseif Value.value.type == "boo" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 2)
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, Value.value.value and 1 or 0)
			else
				error("Invalid variant")
			end
		end,
	},
	updatedSkillUi = {
		SetCallback = function(Callback: (((unknown)?)) -> ()): () -> ()
			events[1] = Callback
			for _, value in event_queue[1] do
				task.spawn(Callback, value)
			end
			event_queue[1] = {}
			return function()
				events[1] = nil
			end
		end,
	},
	replicateHit = {
		SetCallback = function(Callback: (({
			weaponName: (string),
			victim: ((string)?),
		})) -> ()): () -> ()
			events[7] = Callback
			for _, value in event_queue[7] do
				task.spawn(Callback, value)
			end
			event_queue[7] = {}
			return function()
				events[7] = nil
			end
		end,
	},
	replicateCast = {
		SetCallback = function(Callback: (({
			firepoint: (Attachment),
			hit: (Vector3),
			beamColor: ((unknown)?),
		})) -> ()): () -> ()
			events[8] = Callback
			for _, value in event_queue[8] do
				task.spawn(Callback, value)
			end
			event_queue[8] = {}
			return function()
				events[8] = nil
			end
		end,
	},
	updateUI = {
		SetCallback = function(Callback: (({
			zombies: ((number)?),
			wave: ((number)?),
			wavesTillBoss: ((number)?),
			timeLeft: ((number)?),
			gameActive: ((boolean)?),
		})) -> ()): () -> ()
			events[9] = Callback
			for _, value in event_queue[9] do
				task.spawn(Callback, value)
			end
			event_queue[9] = {}
			return function()
				events[9] = nil
			end
		end,
	},
	updateLevelUi = {
		SetCallback = function(Callback: (({
			level: (number),
			xp: (number),
			xpMax: (number),
		})) -> ()): () -> ()
			events[10] = Callback
			for _, value in event_queue[10] do
				task.spawn(Callback, value)
			end
			event_queue[10] = {}
			return function()
				events[10] = nil
			end
		end,
	},
	updateFeeds = {
		SetCallback = function(Callback: (({
			type: (string),
			amtGain: (number),
			reason: (string),
		})) -> ()): () -> ()
			events[11] = Callback
			for _, value in event_queue[11] do
				task.spawn(Callback, value)
			end
			event_queue[11] = {}
			return function()
				events[11] = nil
			end
		end,
	},
	showVoteUi = {
		SetCallback = function(Callback: (({ (string) })) -> ()): () -> ()
			events[12] = Callback
			for _, value in event_queue[12] do
				task.spawn(Callback, value)
			end
			event_queue[12] = {}
			return function()
				events[12] = nil
			end
		end,
	},
	tpToMap = {
		SetCallback = function(Callback: ((string)) -> ()): () -> ()
			events[16] = Callback
			for _, value in event_queue[16] do
				task.spawn(Callback, value)
			end
			event_queue[16] = {}
			return function()
				events[16] = nil
			end
		end,
	},
	getSkillTree = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 17)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[17][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[17][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getFirerate = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 18)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[18][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[18][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getSkillPoints = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 19)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[19][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[19][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getTopbarUIInfo = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 20)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[20][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[20][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getLevelData = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 21)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[21][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[21][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getOwnedWeapons = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 22)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[22][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[22][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
}
