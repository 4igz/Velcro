--!native
--!optimize 2
--!nocheck
--!nolint
--#selene: allow(unused_variable, shadowing, incorrect_standard_library_use)
-- Client generated by Zap v0.6.2 (https://github.com/red-blox/zap)
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")

local outgoing_buff: buffer
local outgoing_used: number
local outgoing_size: number
local outgoing_inst: { Instance }
local outgoing_apos: number

local incoming_buff: buffer
local incoming_read: number
local incoming_inst: { Instance }
local incoming_ipos: number

-- thanks to https://dom.rojo.space/binary.html#cframe
local CFrameSpecialCases = {
	CFrame.Angles(0, 0, 0),
	CFrame.Angles(math.rad(90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(180)),
	CFrame.Angles(math.rad(-90), 0, 0),
	CFrame.Angles(0, math.rad(180), math.rad(90)),
	CFrame.Angles(0, math.rad(90), math.rad(90)),
	CFrame.Angles(0, 0, math.rad(90)),
	CFrame.Angles(0, math.rad(-90), math.rad(90)),
	CFrame.Angles(math.rad(-90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(-90), 0),
	CFrame.Angles(math.rad(90), math.rad(-90), 0),
	CFrame.Angles(0, math.rad(90), math.rad(180)),
	CFrame.Angles(0, math.rad(-90), math.rad(180)),
	CFrame.Angles(0, math.rad(180), math.rad(0)),
	CFrame.Angles(math.rad(-90), math.rad(-180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(180)),
	CFrame.Angles(math.rad(90), math.rad(180), math.rad(0)),
	CFrame.Angles(0, math.rad(0), math.rad(-90)),
	CFrame.Angles(0, math.rad(-90), math.rad(-90)),
	CFrame.Angles(0, math.rad(-180), math.rad(-90)),
	CFrame.Angles(0, math.rad(90), math.rad(-90)),
	CFrame.Angles(math.rad(90), math.rad(90), 0),
	CFrame.Angles(0, math.rad(90), 0),
	CFrame.Angles(math.rad(-90), math.rad(90), 0),
}

local function alloc(len: number)
	if outgoing_used + len > outgoing_size then
		while outgoing_used + len > outgoing_size do
			outgoing_size = outgoing_size * 2
		end

		local new_buff = buffer.create(outgoing_size)
		buffer.copy(new_buff, 0, outgoing_buff, 0, outgoing_used)

		outgoing_buff = new_buff
	end

	outgoing_apos = outgoing_used
	outgoing_used = outgoing_used + len

	return outgoing_apos
end

local function read(len: number)
	local pos = incoming_read
	incoming_read = incoming_read + len

	return pos
end

local function save()
	return {
		buff = outgoing_buff,
		used = outgoing_used,
		size = outgoing_size,
		inst = outgoing_inst,
	}
end

local function load(data: {
	buff: buffer,
	used: number,
	size: number,
	inst: { Instance },
})
	outgoing_buff = data.buff
	outgoing_used = data.used
	outgoing_size = data.size
	outgoing_inst = data.inst
end

local function load_empty()
	outgoing_buff = buffer.create(64)
	outgoing_used = 0
	outgoing_size = 64
	outgoing_inst = {}
end

load_empty()

local types = {}
if RunService:IsServer() then
	error("Cannot use the client module on the server!")
end

local reliable = ReplicatedStorage:WaitForChild("ZAP_RELIABLE")
local unreliable = ReplicatedStorage:WaitForChild("ZAP_UNRELIABLE")

assert(reliable:IsA("RemoteEvent"), "Expected ZAP_RELIABLE to be a RemoteEvent")
assert(unreliable:IsA("UnreliableRemoteEvent"), "Expected ZAP_UNRELIABLE to be an UnreliableRemoteEvent")

local time = 0
export type Skill = ({
	unlocked: (boolean),
	level: (number),
})
function types.write_Skill(value: Skill)
	alloc(1)
	buffer.writeu8(outgoing_buff, outgoing_apos, value.unlocked and 1 or 0)
	alloc(4)
	buffer.writei32(outgoing_buff, outgoing_apos, value.level)
end
function types.read_Skill()
	local value;
	value = {}
	value.unlocked = buffer.readu8(incoming_buff, read(1)) == 1
	value.level = buffer.readi32(incoming_buff, read(4))
	return value
end
export type WeaponSkills = ({ [(string)]: (Skill) })
function types.write_WeaponSkills(value: WeaponSkills)
	local len_pos = alloc(2)
	local len = 0
	for k, v in value do
		len = len + 1
		local len = #k
		alloc(2)
		buffer.writeu16(outgoing_buff, outgoing_apos, len)
		alloc(len)
		buffer.writestring(outgoing_buff, outgoing_apos, k, len)
		types.write_Skill(v)
	end
	buffer.writeu16(outgoing_buff, len_pos, len)
end
function types.read_WeaponSkills()
	local value;
	value = {}
	for _ = 1, buffer.readu16(incoming_buff, read(2)) do
		local key
		local val
		local len = buffer.readu16(incoming_buff, read(2))
		key = buffer.readstring(incoming_buff, read(len), len)
		val = types.read_Skill()
		value[key] = val
	end
	return value
end
export type SkillTree = ({
	pistol: (WeaponSkills),
	sniper: (WeaponSkills),
	shotgun: (WeaponSkills),
	rifle: (WeaponSkills),
	smg: (WeaponSkills),
})
function types.write_SkillTree(value: SkillTree)
	types.write_WeaponSkills(value.pistol)
	types.write_WeaponSkills(value.sniper)
	types.write_WeaponSkills(value.shotgun)
	types.write_WeaponSkills(value.rifle)
	types.write_WeaponSkills(value.smg)
end
function types.read_SkillTree()
	local value;
	value = {}
	value.pistol = types.read_WeaponSkills()
	value.sniper = types.read_WeaponSkills()
	value.shotgun = types.read_WeaponSkills()
	value.rifle = types.read_WeaponSkills()
	value.smg = types.read_WeaponSkills()
	return value
end

RunService.Heartbeat:Connect(function(dt)
	time += dt

	if time >= (1 / 61) then
		time -= (1 / 61)

		if outgoing_used ~= 0 then
			local buff = buffer.create(outgoing_used)
			buffer.copy(buff, 0, outgoing_buff, 0, outgoing_used)

			reliable:FireServer(buff, outgoing_inst)

			outgoing_buff = buffer.create(64)
			outgoing_used = 0
			outgoing_size = 64
			table.clear(outgoing_inst)
		end
	end
end)

local events = table.create(32)
local event_queue: { [number]: { any } } = table.create(32)
local function_call_id = 0
event_queue[1] = {}
event_queue[8] = {}
event_queue[9] = {}
event_queue[10] = {}
event_queue[11] = 0
event_queue[12] = {}
event_queue[13] = {}
event_queue[14] = {}
event_queue[16] = {}
event_queue[17] = {}
event_queue[18] = {}
event_queue[19] = {}
event_queue[23] = {}
event_queue[24] = table.create(255)
event_queue[25] = table.create(255)
event_queue[26] = table.create(255)
event_queue[27] = table.create(255)
event_queue[28] = table.create(255)
event_queue[29] = table.create(255)
event_queue[30] = table.create(255)
event_queue[31] = table.create(255)
event_queue[32] = table.create(255)
reliable.OnClientEvent:Connect(function(buff, inst)
	incoming_buff = buff
	incoming_inst = inst
	incoming_read = 0
	incoming_ipos = 0
	local len = buffer.len(buff)
	while incoming_read < len do
		local id = buffer.readu8(buff, read(1))
		if id == 1 then
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			if events[1] then
				task.spawn(events[1], value)
			else
				table.insert(event_queue[1], value)
				if #event_queue[1] > 64 then
					warn(`[ZAP] {#event_queue[1]} events in queue for updatedSkillUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 8 then
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			if events[8] then
				task.spawn(events[8], value)
			else
				table.insert(event_queue[8], value)
				if #event_queue[8] > 64 then
					warn(`[ZAP] {#event_queue[8]} events in queue for missionUpdated. Did you forget to attach a listener?`)
				end
			end
		elseif id == 9 then
			local value
			value = {}
			value.taskId = buffer.readi32(incoming_buff, read(4))
			value.goalId = buffer.readi32(incoming_buff, read(4))
			if events[9] then
				task.spawn(events[9], value)
			else
				table.insert(event_queue[9], value)
				if #event_queue[9] > 64 then
					warn(`[ZAP] {#event_queue[9]} events in queue for missionGoalCompleted. Did you forget to attach a listener?`)
				end
			end
		elseif id == 10 then
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			if events[10] then
				task.spawn(events[10], value)
			else
				table.insert(event_queue[10], value)
				if #event_queue[10] > 64 then
					warn(`[ZAP] {#event_queue[10]} events in queue for updateLbData. Did you forget to attach a listener?`)
				end
			end
		elseif id == 11 then
			local value
			if events[11] then
				task.spawn(events[11], value)
			else
				event_queue[11] += 1
				if event_queue[11] > 16 then
					warn(`[ZAP] {#event_queue[11]} events in queue for replicateKill. Did you forget to attach a listener?`)
				end
			end
		elseif id == 12 then
			local value
			value = {}
			value.taskId = buffer.readi32(incoming_buff, read(4))
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value.goalId = incoming_inst[incoming_ipos]
			else
				value.goalId = nil
			end
			if events[12] then
				task.spawn(events[12], value)
			else
				table.insert(event_queue[12], value)
				if #event_queue[12] > 64 then
					warn(`[ZAP] {#event_queue[12]} events in queue for missionRewardClaimed. Did you forget to attach a listener?`)
				end
			end
		elseif id == 14 then
			local value
			value = {}
			incoming_ipos = incoming_ipos + 1
			value.firepoint = incoming_inst[incoming_ipos]
			assert(value.firepoint ~= nil)
			assert(value.firepoint:IsA("Attachment"))
			value.hit = Vector3.new(buffer.readf32(incoming_buff, read(4)), buffer.readf32(incoming_buff, read(4)), buffer.readf32(incoming_buff, read(4)))
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value.beamColor = incoming_inst[incoming_ipos]
			else
				value.beamColor = nil
			end
			if events[14] then
				task.spawn(events[14], value)
			else
				table.insert(event_queue[14], value)
				if #event_queue[14] > 64 then
					warn(`[ZAP] {#event_queue[14]} events in queue for replicateCast. Did you forget to attach a listener?`)
				end
			end
		elseif id == 16 then
			local value
			value = {}
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.zombies = buffer.readu16(incoming_buff, read(2))
			else
				value.zombies = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wave = buffer.readu16(incoming_buff, read(2))
			else
				value.wave = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wavesTillBoss = buffer.readu16(incoming_buff, read(2))
			else
				value.wavesTillBoss = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.timeLeft = buffer.readf64(incoming_buff, read(8))
			else
				value.timeLeft = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.gameActive = buffer.readu8(incoming_buff, read(1)) == 1
			else
				value.gameActive = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				local len = buffer.readu16(incoming_buff, read(2))
				value.playerState = buffer.readstring(incoming_buff, read(len), len)
			else
				value.playerState = nil
			end
			if events[16] then
				task.spawn(events[16], value)
			else
				table.insert(event_queue[16], value)
				if #event_queue[16] > 64 then
					warn(`[ZAP] {#event_queue[16]} events in queue for updateUI. Did you forget to attach a listener?`)
				end
			end
		elseif id == 17 then
			local value
			value = {}
			value.level = buffer.readu32(incoming_buff, read(4))
			value.xp = buffer.readu32(incoming_buff, read(4))
			value.xpMax = buffer.readu32(incoming_buff, read(4))
			if events[17] then
				task.spawn(events[17], value)
			else
				table.insert(event_queue[17], value)
				if #event_queue[17] > 64 then
					warn(`[ZAP] {#event_queue[17]} events in queue for updateLevelUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 18 then
			local value
			value = {}
			local len = buffer.readu16(incoming_buff, read(2))
			value.type = buffer.readstring(incoming_buff, read(len), len)
			value.amtGain = buffer.readi32(incoming_buff, read(4))
			local len = buffer.readu16(incoming_buff, read(2))
			value.reason = buffer.readstring(incoming_buff, read(len), len)
			if events[18] then
				task.spawn(events[18], value)
			else
				table.insert(event_queue[18], value)
				if #event_queue[18] > 64 then
					warn(`[ZAP] {#event_queue[18]} events in queue for updateFeeds. Did you forget to attach a listener?`)
				end
			end
		elseif id == 19 then
			local value
			value = {}
			local len = buffer.readu16(incoming_buff, read(2))
			for i = 1, len do
				local value_v
				local len = buffer.readu16(incoming_buff, read(2))
				value_v = buffer.readstring(incoming_buff, read(len), len)
				value[i] = value_v
			end
			if events[19] then
				task.spawn(events[19], value)
			else
				table.insert(event_queue[19], value)
				if #event_queue[19] > 64 then
					warn(`[ZAP] {#event_queue[19]} events in queue for showVoteUi. Did you forget to attach a listener?`)
				end
			end
		elseif id == 23 then
			local value
			local len = buffer.readu16(incoming_buff, read(2))
			value = buffer.readstring(incoming_buff, read(len), len)
			if events[23] then
				task.spawn(events[23], value)
			else
				table.insert(event_queue[23], value)
				if #event_queue[23] > 64 then
					warn(`[ZAP] {#event_queue[23]} events in queue for tpToMap. Did you forget to attach a listener?`)
				end
			end
		elseif id == 24 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			task.spawn(event_queue[24][call_id], value)
			event_queue[24][call_id] = nil
		elseif id == 25 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = buffer.readf64(incoming_buff, read(8))
			task.spawn(event_queue[25][call_id], value)
			event_queue[25][call_id] = nil
		elseif id == 26 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.skillPoints = buffer.readi32(incoming_buff, read(4))
			value.rampageEssence = buffer.readi32(incoming_buff, read(4))
			task.spawn(event_queue[26][call_id], value)
			event_queue[26][call_id] = nil
		elseif id == 27 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			task.spawn(event_queue[27][call_id], value)
			event_queue[27][call_id] = nil
		elseif id == 28 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = buffer.readu8(incoming_buff, read(1)) == 1
			task.spawn(event_queue[28][call_id], value)
			event_queue[28][call_id] = nil
		elseif id == 29 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				incoming_ipos = incoming_ipos + 1
				value = incoming_inst[incoming_ipos]
			else
				value = nil
			end
			task.spawn(event_queue[29][call_id], value)
			event_queue[29][call_id] = nil
		elseif id == 30 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.zombies = buffer.readi32(incoming_buff, read(4))
			else
				value.zombies = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wave = buffer.readu16(incoming_buff, read(2))
			else
				value.wave = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.wavesTillBoss = buffer.readu16(incoming_buff, read(2))
			else
				value.wavesTillBoss = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.timeLeft = buffer.readf64(incoming_buff, read(8))
			else
				value.timeLeft = nil
			end
			if buffer.readu8(incoming_buff, read(1)) == 1 then
				value.gameActive = buffer.readu8(incoming_buff, read(1)) == 1
			else
				value.gameActive = nil
			end
			task.spawn(event_queue[30][call_id], value)
			event_queue[30][call_id] = nil
		elseif id == 31 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.level = buffer.readu32(incoming_buff, read(4))
			value.xp = buffer.readu32(incoming_buff, read(4))
			value.xpMax = buffer.readu32(incoming_buff, read(4))
			task.spawn(event_queue[31][call_id], value)
			event_queue[31][call_id] = nil
		elseif id == 32 then
			local call_id = buffer.readu8(incoming_buff, read(1))
			local value
			value = {}
			value.equippedWeapons = {}
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.gun = buffer.readstring(incoming_buff, read(len), len)
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.melee = buffer.readstring(incoming_buff, read(len), len)
			local len = buffer.readu16(incoming_buff, read(2))
			value.equippedWeapons.equipment = buffer.readstring(incoming_buff, read(len), len)
			value.ownedWeapons = {}
			local len = buffer.readu16(incoming_buff, read(2))
			for i = 1, len do
				local value_ownedWeapons_v
				local len = buffer.readu16(incoming_buff, read(2))
				value_ownedWeapons_v = buffer.readstring(incoming_buff, read(len), len)
				value.ownedWeapons[i] = value_ownedWeapons_v
			end
			task.spawn(event_queue[32][call_id], value)
			event_queue[32][call_id] = nil
		else
			error("Unknown event id")
		end
	end
end)
unreliable.OnClientEvent:Connect(function(buff, inst)
	incoming_buff = buff
	incoming_inst = inst
	incoming_read = 0
	incoming_ipos = 0
	local id = buffer.readu8(buff, read(1))
	if id == 13 then
		local value
		value = {}
		if buffer.readu8(incoming_buff, read(1)) == 1 then
			incoming_ipos = incoming_ipos + 1
			value.hitPart = incoming_inst[incoming_ipos]
			assert(value.hitPart == nil or value.hitPart:IsA("BasePart"))
		else
			value.hitPart = nil
		end
		value.damage = buffer.readf64(incoming_buff, read(8))
		value.isCritical = buffer.readu8(incoming_buff, read(1)) == 1
		if events[13] then
			task.spawn(events[13], value)
		else
			table.insert(event_queue[13], value)
			if #event_queue[13] > 64 then
				warn(`[ZAP] {#event_queue[13]} events in queue for replicateHit. Did you forget to attach a listener?`)
			end
		end
	else
		error("Unknown event id")
	end
end)
return {
	upgradeSkill = {
		Fire = function(Value: ({
			weapon: (string),
			skill: (number),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 2)
			local len = #Value.weapon
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weapon, len)
			alloc(4)
			buffer.writei32(outgoing_buff, outgoing_apos, Value.skill)
		end,
	},
	joinCurrentRound = {
		Fire = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 3)
		end,
	},
	buyWeapon = {
		Fire = function(Value: ({
			weaponName: (string),
			weaponType: (string),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 4)
			local len = #Value.weaponName
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weaponName, len)
			local len = #Value.weaponType
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.weaponType, len)
		end,
	},
	equipWeapon = {
		Fire = function(Value: (string))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 5)
			local len = #Value
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value, len)
		end,
	},
	fireGun = {
		Fire = function(Value: ({
			hitPos: (Vector3),
			rayHit: ((Instance)?),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 6)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.X)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Y)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Z)
			if Value.rayHit == nil then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 0)
			else
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 1)
				table.insert(outgoing_inst, Value.rayHit)
			end
		end,
	},
	melee = {
		Fire = function()
			local saved = save()
			load_empty()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 7)
			local buff = buffer.create(outgoing_used)
			buffer.copy(buff, 0, outgoing_buff, 0, outgoing_used)
			unreliable:FireServer(buff, outgoing_inst)
			load(saved)
		end,
	},
	useEquipment = {
		Fire = function(Value: ({
			equipmentName: (string),
			hitPos: (Vector3),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 15)
			local len = #Value.equipmentName
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.equipmentName, len)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.X)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Y)
			alloc(4)
			buffer.writef32(outgoing_buff, outgoing_apos, Value.hitPos.Z)
		end,
	},
	voteForMap = {
		Fire = function(Value: (string))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 20)
			local len = #Value
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value, len)
		end,
	},
	deployed = {
		Fire = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 21)
		end,
	},
	attributeChangedEvent = {
		Fire = function(Value: ({
			name: (string),
			value: ({
				type: "num",
				value: (number),
			} | {
				type: "str",
				value: (string),
			} | {
				type: "boo",
				value: (boolean),
			}),
		}))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 22)
			local len = #Value.name
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value.name, len)
			if Value.value.type == "num" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 0)
				alloc(8)
				buffer.writef64(outgoing_buff, outgoing_apos, Value.value.value)
			elseif Value.value.type == "str" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 1)
				local len = #Value.value.value
				alloc(2)
				buffer.writeu16(outgoing_buff, outgoing_apos, len)
				alloc(len)
				buffer.writestring(outgoing_buff, outgoing_apos, Value.value.value, len)
			elseif Value.value.type == "boo" then
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, 2)
				alloc(1)
				buffer.writeu8(outgoing_buff, outgoing_apos, Value.value.value and 1 or 0)
			else
				error("Invalid variant")
			end
		end,
	},
	updatedSkillUi = {
		SetCallback = function(Callback: (((unknown)?)) -> ()): () -> ()
			events[1] = Callback
			for _, value in event_queue[1] do
				task.spawn(Callback, value)
			end
			event_queue[1] = {}
			return function()
				events[1] = nil
			end
		end,
	},
	missionUpdated = {
		SetCallback = function(Callback: (((unknown)?)) -> ()): () -> ()
			events[8] = Callback
			for _, value in event_queue[8] do
				task.spawn(Callback, value)
			end
			event_queue[8] = {}
			return function()
				events[8] = nil
			end
		end,
	},
	missionGoalCompleted = {
		SetCallback = function(Callback: (({
			taskId: (number),
			goalId: (number),
		})) -> ()): () -> ()
			events[9] = Callback
			for _, value in event_queue[9] do
				task.spawn(Callback, value)
			end
			event_queue[9] = {}
			return function()
				events[9] = nil
			end
		end,
	},
	updateLbData = {
		SetCallback = function(Callback: (((unknown)?)) -> ()): () -> ()
			events[10] = Callback
			for _, value in event_queue[10] do
				task.spawn(Callback, value)
			end
			event_queue[10] = {}
			return function()
				events[10] = nil
			end
		end,
	},
	replicateKill = {
		SetCallback = function(Callback: () -> ()): () -> ()
			events[11] = Callback
			for _ = 1, event_queue[11] do
				task.spawn(Callback)
			end
			event_queue[11] = 0
			return function()
				events[11] = nil
			end
		end,
	},
	missionRewardClaimed = {
		SetCallback = function(Callback: (({
			taskId: (number),
			goalId: ((unknown)?),
		})) -> ()): () -> ()
			events[12] = Callback
			for _, value in event_queue[12] do
				task.spawn(Callback, value)
			end
			event_queue[12] = {}
			return function()
				events[12] = nil
			end
		end,
	},
	replicateHit = {
		SetCallback = function(Callback: (({
			hitPart: ((BasePart)?),
			damage: (number),
			isCritical: (boolean),
		})) -> ()): () -> ()
			events[13] = Callback
			for _, value in event_queue[13] do
				task.spawn(Callback, value)
			end
			event_queue[13] = {}
			return function()
				events[13] = nil
			end
		end,
	},
	replicateCast = {
		SetCallback = function(Callback: (({
			firepoint: (Attachment),
			hit: (Vector3),
			beamColor: ((unknown)?),
		})) -> ()): () -> ()
			events[14] = Callback
			for _, value in event_queue[14] do
				task.spawn(Callback, value)
			end
			event_queue[14] = {}
			return function()
				events[14] = nil
			end
		end,
	},
	updateUI = {
		SetCallback = function(Callback: (({
			zombies: ((number)?),
			wave: ((number)?),
			wavesTillBoss: ((number)?),
			timeLeft: ((number)?),
			gameActive: ((boolean)?),
			playerState: ((string)?),
		})) -> ()): () -> ()
			events[16] = Callback
			for _, value in event_queue[16] do
				task.spawn(Callback, value)
			end
			event_queue[16] = {}
			return function()
				events[16] = nil
			end
		end,
	},
	updateLevelUi = {
		SetCallback = function(Callback: (({
			level: (number),
			xp: (number),
			xpMax: (number),
		})) -> ()): () -> ()
			events[17] = Callback
			for _, value in event_queue[17] do
				task.spawn(Callback, value)
			end
			event_queue[17] = {}
			return function()
				events[17] = nil
			end
		end,
	},
	updateFeeds = {
		SetCallback = function(Callback: (({
			type: (string),
			amtGain: (number),
			reason: (string),
		})) -> ()): () -> ()
			events[18] = Callback
			for _, value in event_queue[18] do
				task.spawn(Callback, value)
			end
			event_queue[18] = {}
			return function()
				events[18] = nil
			end
		end,
	},
	showVoteUi = {
		SetCallback = function(Callback: (({ (string) })) -> ()): () -> ()
			events[19] = Callback
			for _, value in event_queue[19] do
				task.spawn(Callback, value)
			end
			event_queue[19] = {}
			return function()
				events[19] = nil
			end
		end,
	},
	tpToMap = {
		SetCallback = function(Callback: ((string)) -> ()): () -> ()
			events[23] = Callback
			for _, value in event_queue[23] do
				task.spawn(Callback, value)
			end
			event_queue[23] = {}
			return function()
				events[23] = nil
			end
		end,
	},
	getSkillTree = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 24)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[24][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[24][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getFirerate = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 25)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[25][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[25][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getSkillPoints = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 26)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[26][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[26][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getPlayerMissions = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 27)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[27][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[27][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	claimMissionRewards = {
		Call = function(Value: (number))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 28)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[28][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			alloc(4)
			buffer.writei32(outgoing_buff, outgoing_apos, Value)
			event_queue[28][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getLbData = {
		Call = function(Value: (string))
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 29)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[29][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			local len = #Value
			alloc(2)
			buffer.writeu16(outgoing_buff, outgoing_apos, len)
			alloc(len)
			buffer.writestring(outgoing_buff, outgoing_apos, Value, len)
			event_queue[29][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getTopbarUIInfo = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 30)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[30][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[30][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getLevelData = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 31)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[31][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[31][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
	getOwnedWeapons = {
		Call = function()
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, 32)
			function_call_id += 1
			function_call_id %= 256
			if event_queue[32][function_call_id] then
				function_call_id -= 1
				error("Zap has more than 256 calls awaiting a response, and therefore this packet has been dropped")
			end
			alloc(1)
			buffer.writeu8(outgoing_buff, outgoing_apos, function_call_id)
			event_queue[32][function_call_id] = coroutine.running()
			local value = coroutine.yield()
			return value
		end,
	},
}
